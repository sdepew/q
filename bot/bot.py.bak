"""
Slack chat-bot Lambda handler.
"""

import os
import json
import urllib
import re
import requests
import random
from datetime import datetime, time, timedelta
from bot.commons import *
from bot.command_map import command_map

# Python Logging stuff
import logging
logger = logging.getLogger()
LogLevel = os.environ['LOG_LEVEL']
if LogLevel == "DEBUG":
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)
def log_handler(event):
    logger.info('EVENT: {}'.format(event))
    return None

# Grab the Bot OAuth token from the environment.
BOT_TOKEN = os.environ["BOT_TOKEN"]

# Grab the Bot Name from the environment
BOT_NAME = os.environ["BOT_NAME"]
BOT_ID = os.environ["BOT_ID"]
BOT_MENTION = "<@{}>".format(BOT_ID)

# Grab the Slack Webhook URL token from the environment.
SLACK_URL = os.environ["INTO_SLACK_URL"]

# TODO Need to break this out into a mapping system.
known_commands = ["chuck", "food", "motivation", "nasa", "reverse", "shrug", "weather"]

def runCommand():
    pass


def motivation(query=[], user=None):
    '''Get a motivation image. Usage: !motivation'''

    try:
        params = {'generate': 'true'}
        inspiro_response = requests.get('http://inspirobot.me/api',
                                        params).text
        return inspiro_response.replace('http://', 'https://')
    except requests.exceptions.RequestException as e:
        logger.error('Failure getting image from inspirobot! {}'.format(e))
        return ERROR_IMAGE

def lambda_handler(data, context):
    """Handle an incoming HTTP request from a Slack chat-bot.
    """
    if "challenge" in data:
        return data["challenge"]

    # Grab the Slack event data.
    logger.debug("New Request Received: {}".format(data))
    slack_event = data['event']
    event_text = slack_event['text']
    logging.debug("Request: {}".format(slack_event))

    # We need to discriminate between events generated by
    # the users, which we want to process and handle,
    # and those generated by the bot until there is a way to subscribe to
    # specific calls.
    if "bot_id" in slack_event:
        logger.debug("Ignore bot event\n-START-{}-END-".format(slack_event))
    elif not event_text.startswith(BOT_MENTION) and not event_text.startswith("!"):
        logger.debug("Ignoring input as it was not directed at bot.\n-START-{}-END-".format(slack_event))
    else:
        logger.debug("PROCESSING COMMAND:\n-----START-----\n{}\n-----END-----\n".format(slack_event))
        if event_text.startswith(BOT_MENTION):
            text = slack_event["text"].lstrip(BOT_MENTION)

        if event_text.startswith("!"):
            input = event_text.lstrip('!').split(" ")
            if input[0] == "motivation":
                command = motivation()
            elif input[0] == "now":
                command = datetime.now().strftime("%x %X")
            elif input[0] == "chuck":
                from bot.commands.chuck import chuck
                command = chuck()
            elif input[0] == "nasa":
                from bot.commands.nasa import potd, mars
                input.pop(0)
                if not input:
                    command = random.choice([potd(), mars()])
                elif input[0] == "mars":
                    command = mars()
                else:
                    command = "Open the pod bay doors, HAL."
            elif input[0] == 'help':
                input.pop(0)
                if not input:
                    command = "I know how to do: {}".format(", ".join(sorted(["!" + x for x in known_commands])))
                else:
                    # TODO Replace this with a help map to retrieve help from each function.
                    command = "I know how to do: {}".format(", ".join(sorted(["!" + x for x in known_commands])))
            elif input[0].startswith('reverse'):
                input.pop(0)
                if not input:
                    return help("reverse")
                command = " ".join(input)[::-1]
            elif input[0].startswith('shrug'):
                command = "¯\\_(ツ)_/¯"
            elif input[0].startswith('weather'):
                from bot.commands.weather import weather
                input.pop(0)
                if not input:
                    command = "Usage: !weather 20170 [forecast]"
                else:
                    if re.findall('\d{4,5}$', input[0])[0] and len(input) == 1: # Check if 5 digits.
                        command = weather(call_type="weather", zip_code=input[0])
                    elif any("forecast" in f for f in input) and input[1] == "forecast":
                        command = weather(call_type="forecast", zip_code=input[0])
                    else:
                        return "Hmm something wen't wrong: {}".format("".join(input))
            elif input[0].startswith('food'):
                from bot.commands.food import food
                DEFAULT_LOCATION = 'Herndon, VA'
                # TODO Make the time delta variable depending on user's timezone.
                current_time = datetime.fromtimestamp(float(slack_event['event_ts'])) - timedelta(hours=5)
                print("RAW CURRENT TIME: ", current_time.time())
                print("slack_event['event_ts']: ", slack_event['event_ts'])
                logger.debug("CURRENT TIME: {}".format(current_time))
                if current_time.time() >= time(10,30) and current_time.time() <= time(13,30):
                    DEFAULT_TERM = 'lunch'
                elif current_time.time() >= time(13,31) and current_time.time() <= time(22,00):
                    DEFAULT_TERM = 'dinner'
                elif current_time.time() >= time(0,0) and current_time.time() <= time(10,29):
                    DEFAULT_TERM = 'breakfast'
                else:
                    DEFAULT_TERM = 'bars'
                logger.debug("CURRENT TIME created a default of {}".format(DEFAULT_TERM))
                SEARCH_LIMIT = 30
                input.pop(0)
                if not input: # Handle just calling !food
                    command = "No Food for you, maybe try !food Cut and Shoot, TX"
                elif len(input) >= 1:
                    DEFAULT_LOCATION = "".join(input)
                    command = food(DEFAULT_LOCATION, DEFAULT_TERM)
                else:
                    command = "Usage: !food [location]"
            else:
                command = "Sorry, I dont know how to do \'{}\'".format(input[0])
            return_text = command
        else:
            return_text = random.choice(qisims)

        # Get the ID of the channel where the message was posted.
        channel_id = slack_event["channel"]

        # Generate Request
        headers = {"Content-type": "application/json"}
        payload =  {"text": str(return_text)}
        logger.debug("Sending payload: {}\nType of payload: {}".format(payload, type(payload)))
        slack_response = requests.post(SLACK_URL, json=payload)
        if slack_response.status_code == 200:
            return None
        else:
            logger.error("Unable to send to Slack: {}".format(slack_response.content))
            return None

    # Everything went fine.
    return "200 OK"
